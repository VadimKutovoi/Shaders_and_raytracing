#version 430

in vec3 origin, direction;
out vec4 outputColor;

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 reflection;
    vec3 specular;
    vec3 transparency;
    vec3 emission;
    vec3 atenuation;
    float refractionCoef;
    float shiness;
};

struct Sphere {
    vec3 position;
    float radius;
    Material color;
};

struct Ray {
    vec3 origin;
    vec3 direction;
    int type;
};

struct RayNode {
    Ray ray;
	vec3 reflectionColor;
	vec3 refractionColor;
	vec3 diffuseColor;
	vec3 specular;
	vec3 reflection;
	vec3 refraction;
    vec3 specular;
    int parentIndex;
    int depth;
};

struct HitInfo {
    bool hitDetected;
    vec3 hitPoint;
    vec3 surfaceNormal;
    float distance;
    int objectid;
    vec3 color;
};


const int sphereNumber = 3;
Sphere spheres[3];
const int Max_Depth = 5;
const int Max_Nodes = 64;
const int TYPE_DIFFUSE = 1;
const int TYPE_SHADOW = 2;
const int TYPE_REFLECTION = 3;
const int TYPE_TRANSPARENCY = 4;
float coeff = 1;
RayNode rayNode[Max_Nodes];

void sphereIntersect(Ray ray, int objectid, inout HitInfo hitInfo) {
    Sphere sphere = spheres[objectid];
    vec3 trackToSphere = ray.origin - sphere.position;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(trackToSphere, ray.direction);
    float c = dot(trackToSphere, trackToSphere) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4.0 * a * c;    

    if (discriminant > 0.0) {
	float distance = (-b - sqrt(discriminant)) / (2.0 * a);
	if (distance > 0.0001 && hitInfo.objectid ==0 && (distance < hitInfo.distance && hitInfo.hitDetected || !hitInfo.hitDetected)) {
	    hitInfo.distance = distance;
	    hitInfo.hitPoint = ray.origin + ray.direction *  hitInfo.distance;
  	    hitInfo.surfaceNormal = normalize(hitInfo.hitPoint - sphere.position);
	    hitInfo.hitDetected = true;
	    hitInfo.objectid = objectid;
	    hitInfo.color = sphere.color;
	}
    }
}

vec3 iterativeRayTrace(Ray ray) {
    Sphere sphere;
    sphere.position = vec3(0.5, 0.0, 0.0);
    sphere.radius = 0.2;
    sphere.color = vec3(0.3, 0.1, 0.7);	
    int numberOfNodes = 1, currentNodeIndex = 0;
    spheres[0] = sphere;
    sphere.position = vec3(0.3, 0.0, -1.0);
    sphere.radius = 1.0;
    sphere.color = vec3(0.6, 0.5, 0.2);	
    spheres[1] = sphere;
    sphere.position = vec3(-0.5, 0.0, 0.0);
    sphere.radius = 0.2;
    sphere.color = vec3(0.3, 0.1, 0.7);		
    spheres[2] = sphere;	

    rayNode[currentNodeIndex].ray = ray;
    rayNode[currentNodeIndex].depth = 0;

    while (currentNodeIndex < numberOfNodes) {
	rayNode[currentNodeIndex].diffuseColor = vec3(0);
	rayNode[currentNodeIndex].reflectionColor = vec3(0);
	rayNode[currentNodeIndex].refractionColor = vec3(0);
	
	HitInfo hitInfo;
	hitInfo.hitDetected = false;
	for(int i = 0; i < sphereNumber; i++)
		sphereIntersect(rayNode[currentNodeIndex].ray, i, hitInfo);
	
	//sphereIntersect(ray, 0, hitInfo);
        //sphereIntersect(ray, 1, hitInfo);
	//sphereIntersect(ray, 2, hitInfo);
	
	if (hitInfo.hitDetected) {
   		Material material = spheres[hitInfo.objectid].material;
		rayNode[currentNodeIndex].specular = material.specular;
		rayNode[currentNodeIndex].reflection = material.reflection;
		rayNode[currentNodeIndex].refraction = material.transparency;
		if(length(material.reflection) > 0.0 && rayNode[currentNodeIndex].depth < MAX_DEPTH)
		{
			vec3 reflectionDir = normalize(reflect(rayNode[currentNodeIndex].ray.direction, hitInfo.surfaceNormal));
			vec3 offeset = reflectionDir * 0.01;
			rayNode[numberOfNodes].ray = Ray(hitInfo.hitPoint + offset, reflectionDir, TYPE_REFLECTION);
			rayNode[numberOfNodes].parentIndex = currentNodeIndex; 
			rayNode[numberOfNodes].depth = rayNode[currentNodeIndex].depth + 1;
			numberOfNodes++;
		}
		if(length(material.reflection) > 0.0 && rayNode[currentNodeIndex].depth < MAX_DEPTH)
		{
			vec3 refractionDir = normalize(refract(rayNode[currentNodeIndex].ray.direction, hitInfo.surfaceNormal));
			vec3 offeset = reflectionDir * 0.01;
			rayNode[numberOfNodes].ray = Ray(hitInfo.hitPoint + offset, reflectionDir, TYPE_TRANSPARENCY);
			rayNode[numberOfNodes].parentIndex = currentNodeIndex; 
			rayNode[numberOfNodes].depth = rayNode[currentNodeIndex].depth + 1;
			numberOfNodes++;
		}
		if(length(material.ambient) > 0.0 || length(material.diffuse) > 0.0 || length(material.specular) > 0.0 || rayNode[currentNodeIndex].depth >= MAX_DEPTH)
		{
			rayNode[currentNodeIndex].diffuseColor = calculateColor(hitInfo);
		}
		else
		{
			rayNode[currentNodeIndex].diffuseColor = vec3(0,0,0);
		}
		currentNodeIndex++;
		
		for(int i = currentNodeIndex - 1; i>0; i--){
			vec3 nodeColor = rayNode[i].diffuseColor + rayNode[i].reflectionColor * rayNode[i].reflection + rayNode[i].refractionColor * rayNode[i].refraction;
            if(rayNode[i].ray.type == TYPE_REFLECTION)
                rayNode[rayNode[i].parentIndex].reflectionColor = nodeColor;
            else if(rayNode[i].ray.type == TYPE_TRANSPARENCY)
                rayNode[rayNode[i].parentIndex].refractionColor = nodeColor;
		}
		return clamp(rayNode[0].diffuseColor)
	}
	rayNode[currentNodeIndex].color = hitInfo.color * coeff;
	}
	else rayNode[currentNodeIndex].color = vec3(0, 0, 0);
	currentNodeIndex++;
    }
    return rayNode[0].color;
}

	

void main()
{
    Ray ray = Ray(origin, direction);
    outputColor = vec4(iterativeRayTrace(ray), 1.0) ;
}